package httpfs

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// EmbeddedDir returns a new `http.FileSystem`
// for an embedded directory generated by `go-bindata`.
//
// It accepts the virtual directory following
// by the generated functions for accessing embedded files.
//
// Usage:
// fileSystem := EmbeddedDir("./assets", Asset, AssetInfo, AssetNames)
// fileServer := FileServer(fileSystem, DefaultOptions)
func EmbeddedDir(vdir string,
	assetFn func(name string) ([]byte, error),
	assetInfoFn func(name string) (os.FileInfo, error),
	assetNamesFn func() []string) http.FileSystem {

	if vdir != "" {
		if len(vdir) > 1 {
			if vdir[0] == '.' && len(vdir) > 1 {
				vdir = vdir[1:]
			}

			if vdir[0] == '/' || vdir[0] == os.PathSeparator {
				vdir = vdir[1:]
			}
		}

		if trailingSlashIdx := len(vdir) - 1; vdir[trailingSlashIdx] == '/' {
			vdir = vdir[0:trailingSlashIdx]
		}
	}

	// Select only the paths that we care;
	// that have prefix of the directory and
	// skip any unnecessary the end-dev or the 3rd party tool may set.
	var names []string
	for _, name := range assetNamesFn() {
		if !strings.HasPrefix(name, vdir) {
			continue
		}

		names = append(names, filepath.ToSlash(name))
	}

	if len(names) == 0 {
		panic("FileServer: zero embedded files")
	}

	asset := assetFn
	// make .Name() infos like http.Dir (base names instead of full names).
	assetInfo := func(name string) (os.FileInfo, error) {
		info, err := assetInfoFn(name)
		if err != nil {
			return nil, err
		}
		return &embeddedBaseFileInfo{
			baseName: path.Base(info.Name()),
			FileInfo: info,
		}, nil
	}

	dirNames := make(map[string]*embeddedDir)

	// sort filenames by smaller path.
	sort.Slice(names, func(i, j int) bool {
		return strings.Count(names[j], "/") > strings.Count(names[i], "/")
	})

	for _, name := range names {
		dirName := path.Dir(name)
		d, ok := dirNames[dirName]

		if !ok {
			d = &embeddedDir{
				name:        dirName,
				baseName:    path.Base(dirName),
				modTimeUnix: time.Now().Unix(),
			}
			dirNames[dirName] = d
		}

		info, err := assetInfo(name)
		if err != nil {
			panic(fmt.Sprintf("FileServer: report as bug: file info: %s not found in: %s", name, dirName))
		}

		// Add the directory file info (=this dir) to the parent one,
		// so `ShowList` can render sub-directories of this dir.
		if parent, hasParent := dirNames[path.Dir(dirName)]; hasParent {
			parent.list = append(parent.list, d)
		}

		f := &embeddedBaseFileInfo{path.Base(name), info}
		d.list = append(d.list, f)
	}

	return &embeddedFileSystem{
		vdir:     vdir,
		dirNames: dirNames,

		asset:     asset,
		assetInfo: assetInfo,
	}
}

type embeddedFileSystem struct {
	vdir string
	// Go-bindata tools don't give that info,
	// so we initialize it in order to support
	// `ShowList` on embedded files as well.
	dirNames map[string]*embeddedDir

	asset     func(name string) ([]byte, error)
	assetInfo func(name string) (os.FileInfo, error)
}

var _ http.FileSystem = (*embeddedFileSystem)(nil)

// Open implements FileSystem using os.Open, opening files for reading rooted
// and relative to the virtual directory.
func (fs *embeddedFileSystem) Open(name string) (http.File, error) {
	if name != "/" {
		// http://localhost:8080/app2/app2app3/dirs/
		// = http://localhost:8080/app2/app2app3/dirs
		name = strings.TrimSuffix(name, "/")
	}

	name = path.Join(fs.vdir, path.Clean("/"+name))
	if d, ok := fs.dirNames[name]; ok {
		return d, nil
	}

	info, err := fs.assetInfo(name)
	if err != nil {
		return nil, err
	}
	b, err := fs.asset(name)
	if err != nil {
		return nil, err
	}

	return &embeddedFile{
		FileInfo:   info,
		ReadSeeker: bytes.NewReader(b),
	}, nil
}

type embeddedFile struct {
	os.FileInfo
	io.ReadSeeker
}

var _ http.File = (*embeddedFile)(nil)

func (f *embeddedFile) Close() error {
	return nil
}

func (f *embeddedFile) Readdir(count int) ([]os.FileInfo, error) {
	return nil, nil // should never happen, read directories is done by `embeddedDir`.
}

func (f *embeddedFile) Stat() (os.FileInfo, error) {
	return f.FileInfo, nil
}

type embeddedBaseFileInfo struct {
	baseName string
	os.FileInfo
}

func (info *embeddedBaseFileInfo) Name() string {
	return info.baseName
	// return path.Base(info.Name())
}

type embeddedDir struct {
	name          string
	baseName      string
	modTimeUnix   int64
	list          []os.FileInfo
	*bytes.Reader // never used, will always be nil.
}

var _ http.File = (*embeddedDir)(nil)

func (f *embeddedDir) Close() error               { return nil }
func (f *embeddedDir) Name() string               { return f.baseName }
func (f *embeddedDir) Size() int64                { return 0 }
func (f *embeddedDir) Mode() os.FileMode          { return os.ModeDir }
func (f *embeddedDir) ModTime() time.Time         { return time.Unix(f.modTimeUnix, 0) }
func (f *embeddedDir) IsDir() bool                { return true }
func (f *embeddedDir) Sys() interface{}           { return f }
func (f *embeddedDir) Stat() (os.FileInfo, error) { return f, nil }

func (f *embeddedDir) Readdir(count int) ([]os.FileInfo, error) {
	if count != -1 {
		// this should never happen, show dirs is already checked on the handler level before this call.
		return nil, nil
	}

	return f.list, nil
}
